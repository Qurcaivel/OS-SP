# OS-SP workspace

This repository contains project dedicated to practice work (aka laboratory works) on OS-SP (Operation systems and system programming).

## Environment

There are following tools was used for project development:

_GCC_

```
❯ gcc --version
gcc (GCC) 12.2.1 20230201
```

_GDB_

```
❯ gdb --version
GNU gdb (GDB) 12.1
```

_Make_

```
❯ make --version
GNU Make 4.4
Built for x86_64-pc-linux-gnu
```

## Development stages

Practice work tasks.

### 1. Знакомство с Linux/Unix и средой программирования. POSIX-совместимая файловая система.

Разработать программу `dirwalk`, сканирующую файловую      систему и выводящую в `stdout` информацию в соответствии с опциями программы.  Формат вывода аналогичен формату вывода  утилиты `find`.

---
```sh
dirwalk [directory] [options]
```

directory - начальный каталог (по умолчанию - './'),

options:
- `l` – только символические ссылки (`-type l`);
- `d` – только каталоги (`-type d`);
- `f` - только файлы (`-type f`);
- `s` — сортировать выход в соответствии с LC_COLLATE.
---

Опции могут быть указаны как перед каталогом, так и после. 

Опции могут быть указаны как раздельно, так и вместе 
(`-l -d`, `-ld`).

Если опции `ldf` опущены, выводятся каталоги, файлы и ссылки.

### 2. Понятие процессов.  

Разработать две программы ‒ `parent` и `child`.

Перед запуском программы `parent` в окружении создается переменная среды _CHILD_PATH_ с именем каталога, где находится программа `child`.

Родительский процесс (программа `parent`) после запуска получает переменные среды, сортирует их в LC_COLLATE=C и выводит в `stdout`, после чего входит в цикл обработки нажатий клавиатуры.

- Символ `+`, используя `fork(2)` и `execve(2)` порождает дочерний процесс и запускает в нем очередной экземпляр программы `child`. Информацию о каталоге, где размещается `child`, получает из окружения, используя функцию `getenv()`. Имя программы (`argv[0]`) устанавливается как child_XX, где XX порядковый номер от 00 до 99,
инкрементируемый родителем.

- Символ `*` порождает дочерний процесс аналогично предыдущему случаю, однако информацию о расположении программы `child` получает, сканируя массив параметров среды, переданный в третьем параметре функции `main()`.

- Символ `&` порождает дочерний процесс аналогично предыдущему случаю, однако информацию о расположении программы `child` получает, сканируя массив параметров среды, указанный во внешней переменной `extern char **environ`, установленной хост-средой при запуске (_см. IEEE Std 1003.1-2017_).

    При запуске дочернего процесса ему передается сокращенное окружение, включающее набор переменных, указанных в файле, который передается родительскому процессу как параметр командной строки. Минимальный набор переменных должен включать _SHELL, HOME, HOSTNAME, LOGNAME, LANG, TERM, USER, LC_COLLATE, PATH_. Дочерний процесс открывает этот файл, считывает имена переменных, получает из окружения их значение и выводит в `stdout`.

    Дочерний процесс (программа `child`) выводит свое имя, pid, ppid, открывает файл с набором переменных, считывает их имена, получает из окружения, переданного ему при запуске, их значение способом, указанным при обработке нажатий, выводит в `stdout` и завершается.

- Символ `q` завершает выполнение родительского процесса.

Программы компилируются с ключами
`-W -Wall -Wno-unused-parameter -Wno-unused-variable -std=c11 -pedantic`.

Для компиляции, сборки и очистки используется `make`.

### 3. Взаимодействие и синхронизация процессов

Синхронизация процессов с помощью сигналов и обработка сигналов таймера.

Управление дочерними процессами и упорядочение вывода в `stdout` от них, используя сигналы `SIGUSR1` и `SIGUSR2`.

**Действия родительского процесса**

По нажатию клавиши `+` pодительский процесс (P) порождает дочерний процесс ($C_k$) и сообщает об этом.

По нажатию клавиши `-` P удаляет последний порожденный $C_k$, сообщает об этом и о количестве оставшихся.

При вводе символа `l` выводится перечень родительских и дочерних процессов.

При вводе символа `k` P удаляет все $C_k$ и сообщает об этом.

При вводе символа `s` P запрещает всем $C_k$ выводить статистику (см. ниже).

При вводе символа `g` P разрешает всем $C_k$ выводить статистику.

При вводе символов `s<num>` P запрещает $C_{<num>}$ выводить статистику.

При вводе символов `g<num>` P разрешает $C_{<num>}$ выводить статистику.

При вводе символов `p<num>` P запрещает всем $C_k$ вывод и запрашивает $C_{<num>}$ вывести свою статистику. По истечению заданного времени, если не введен символ `g`, разрешает всем C_k снова выводить статистику.

По нажатию клавиши `q` P удаляет все $C_k$, сообщает об этом и завершается.

**Действия дочернего процесса**

Дочерний процесс во внешнем цикле заводит будильник (`nanosleep(2)`) и входит в вечный цикл, в котором заполняет структуру, содержащую пару переменных типа `int`,
значениями {0, 0} и {1, 1} в режиме чередования.

При получении сигнала от будильника проверяет содержимое структуры, собирает статистику и повторяет тело внешнего цикла.

Через заданное количество повторений внешнего цикла (например, через 101) дочерний процесс, если ему разрешено, выводит свои PPID, PID и 4 числа — количество
разных пар, зарегистрированных в момент получения сигнала от будильника.

Вывод осуществляется посимвольно (`fputc(3)`).

$C_k$ запрашивает доступ к `stdout` у P и осуществляет вывод после подтверждения. По завершению вывода $C_k$ сообщает P об этом.

Следует подобрать интервал времени ожидания и количество повторений внешнего цикла, чтобы статистика была значимой.

Сообщения выводятся в `stdout`.

Сообщения процессов должны содержать идентифицирующие их данные, чтобы можно было фильтровать вывод утилитой `grep`.

### 4. Задача производители-потребители для процессов

Основной процесс создает очередь сообщений, после чего ожидает и обрабатывает нажатия клавиш, порождая и завершая процессы двух типов — производители и потребители.

Очередь сообщений представляет собой кольцевой буфер, содержащий указатели на сообщения, и пара указателей на голову и хвост. Помимо этого очередь содержит счетчик добавленных сообщений и счетчик извлеченных.

Производители формируют сообщения и, если в очереди есть место, помещают их туда.

Потребители, если в очереди есть сообщения, извлекают их оттуда, обрабатывают и освобождают с ними связанную память.

Для работы используются два семафора для заполнения и извлечения, а также мьютекс или одноместный семафор для монопольного доступа к очереди.

Сообщения имеют следующий формат (размер и смещение в байтах):
| Имя  | Размер                    | Смещение | Описание                            |
|------|---------------------------|----------|-------------------------------------|
| type | 1                         | 0        | тип сообщения                       |
| hash | 2                         | 1        | контрольные данные                  |   
| size | 1                         | 3        | длина данных в байтах (от 0 до 256) |
| data | $((size + 3)/4) \times 4$ | 4        | данные сообщения                    |

Производители генерируют сообщения, используя системный генератор `rand(3)` для _size_ и _data_. В качестве результата для _size_ используется остаток от деления на 257.

Если остаток от деления равен нулю, `rand(3)` вызывается повторно. Если остаток от деления равен 256, значение _size_ устанавливается равным 0, реальная длина сообщения при этом составляет 256 байт.

При формировании сообщения контрольные данные формируются из всех байт сообщения. Значение поля _hash_ при вычислении контрольных данных принимается равным нулю. Для расчета контрольных данных можно использовать любой подходящий алгоритм на выбор студента.

После помещения значения в очередь перед освобождением мьютекса очереди
производитель инкрементирует счетчик добавленных сообщений. Затем после поднятия семафора выводит строку на `stdout`, содержащую помимо всего новое значение этого счетчика.

Потребитель, получив доступ к очереди, извлекает сообщение и удаляет его из очереди. Перед освобождением мьютекса очереди инкрементирует счетчик извлеченных сообщений. Затем после поднятия семафора проверяет контрольные данные и выводит строку на `stdout`, содержащую помимо всего новое значение счетчика извлеченных сообщений.

При получении сигнала о завершении процесс должен завершить свой цикл и только после этого завершиться, не входя в новый.

### 5. Потоки исполнения, взаимодействие и синхронизация

Задача производители-потребители для потоков. Аналогична лабораторной №4, но только с потоками в рамках одного процесса.

Дополнительно обрабатывается еще две клавиши – увеличение и уменьшение раз-
мера очереди.

### 6. Работа с файлами, отображенными в память

_Not available yet..._

### 7. Блокировки чтения/записи и условные переменные

_Not available yet..._

### 8. Сокеты. Взаимодействие процессов.

_Not available yet..._

## Personal work (coursework)

Драйвер USB-клавиатуры.

_Here should be a link to the repository with the course project..._